//------------------------------------------------------------------------------
// Description 
//    
// $Workfile$
// $Revision$
// $Author  $
// $Modtime $
//
//------------------------------------------------------------------------------

#include "base.h"
#include "tagDictionary.h"
#include "m_qsort.h"
#include "streamio.h"
#include "persist.h"
#include "console.h"

namespace {

const char TAG_ASCII_ID[] = "[TAG]";
const char TAG_ASCII_END[] = "[END]";
const char TAG_ASCII_HEADER[] = "// Auto-Generated by TagDictionary class";

const int sg_tagDictAsciiUser   = 1;

}; // namespace {}

TagDictionary tagDictionary;

TagDictionary::TagDictionary()
{
   numBuckets = 29;
   defineHashBuckets = (TagEntry **) malloc(numBuckets * sizeof(TagEntry *));
   idHashBuckets = (TagEntry **) malloc(numBuckets * sizeof(TagEntry *));

   int i;
   for(i = 0; i < numBuckets; i++)
   {
      defineHashBuckets[i] = NULL;
      idHashBuckets[i] = NULL;
   }
   numEntries = 0;
   entryChain = NULL;
}

TagDictionary::~TagDictionary()
{
   free(defineHashBuckets);
   free(idHashBuckets);
}

//------------------------------------------------------------------------------

static inline int hashId(int id, int tsize)
{
   return id % tsize;
}

static inline int hashDefine(StringTableEntry define, int tsize)
{
   return (int(define) >> 2) % tsize;
}

//------------------------------------------------------------------------------

bool TagDictionary::addEntry(int value, StringTableEntry define, StringTableEntry string)
{
   if(!value)
      return false;
   if(idToDefine(value))
   {
      Console->printf("Error: id %d already defined to a tag.", value);
      return false;
   }
   int tempTag;
   if((tempTag = defineToId(define)) != 0)
   {
      Console->printf("Error: define %s already defined to tag %d.", define, tempTag);
      return false;
   }
   TagEntry *newEntry = (TagEntry *) mempool.alloc(sizeof(TagEntry));
   
   newEntry->id = value;
   newEntry->define = define;
   newEntry->string = string;

   numEntries++;
   if(numEntries > numBuckets)
   {
      numBuckets = numBuckets * 2 + 1;
      defineHashBuckets = (TagEntry **) realloc(defineHashBuckets, numBuckets * sizeof(TagEntry *));
      idHashBuckets = (TagEntry **) realloc(idHashBuckets, numBuckets * sizeof(TagEntry *));
      int i;
      for(i = 0; i < numBuckets; i++)
      {
         defineHashBuckets[i] = NULL;
         idHashBuckets[i] = NULL;
      }
      TagEntry *walk = entryChain;
   
      while(walk)
      {
         int index = hashId(walk->id, numBuckets);
         walk->idHashLink = idHashBuckets[index];
         idHashBuckets[index] = walk;

         index = hashDefine(walk->define, numBuckets);
         walk->defineHashLink = defineHashBuckets[index];
         defineHashBuckets[index] = walk;

         walk = walk->chain;
      }
   }
   newEntry->chain = entryChain;
   entryChain = newEntry;

   int index = hashId(newEntry->id, numBuckets);
   newEntry->idHashLink = idHashBuckets[index];
   idHashBuckets[index] = newEntry;

   index = hashDefine(newEntry->define, numBuckets);
   newEntry->defineHashLink = defineHashBuckets[index];
   defineHashBuckets[index] = newEntry;
   return true;
}

//------------------------------------------------------------------------------

int TagDictionary::writeHeader(StreamIO& io_sio)
{
   char buff[15000];
   Vector<int> v;

   TagEntry *walk = entryChain;
   while(walk)
   {
      v.push_back(walk->id);
      walk = walk->chain;
   }

   sortIdVector(v);

   io_sio.write( sizeof(TAG_ASCII_HEADER)-1, TAG_ASCII_HEADER);
   io_sio.write( 4, "\r\n\r\n");
   
   char exclude[256];
   char tempBuf[256];
   sprintf(exclude, "_TD%10.10u_H_", GetTickCount() / 4);
   
   sprintf(tempBuf, "#ifndef %s\r\n", exclude);
   io_sio.write(strlen(tempBuf), tempBuf);
   sprintf(tempBuf, "#define %s\r\n\r\n", exclude);
   io_sio.write(strlen(tempBuf), tempBuf);
   
   for(int i = 0; i < v.size(); i++)
   {
      sprintf(buff, "#define %s (%d)\r\n", idToDefine(v[i]), v[i]);
      io_sio.write(strlen(buff), buff);
   }

   sprintf(tempBuf, "\r\n#endif // %s\r\n", exclude);
   io_sio.write(strlen(tempBuf), tempBuf);

   return ((io_sio.getStatus() == STRM_OK) ? Persistent::Base::Ok : Persistent::Base::WriteError);
}

//------------------------------------------------------------------------------

StringTableEntry TagDictionary::defineToString(StringTableEntry tag)
{
   int index = hashDefine(tag, numBuckets);
   if (index < 0) return NULL;
   TagEntry *walk = defineHashBuckets[index];
   while(walk)
   {
      if(walk->define == tag)
         return walk->string;
      walk = walk->defineHashLink;
   }
   return NULL;
}

int TagDictionary::defineToId(StringTableEntry tag)
{
   int index = hashDefine(tag, numBuckets);
   if (index < 0) return 0;
   TagEntry *walk = defineHashBuckets[index];
   while(walk)
   {
      if(walk->define == tag)
         return walk->id;
      walk = walk->defineHashLink;
   }
   return 0;
}

StringTableEntry TagDictionary::idToString(int id)
{
   int index = hashId(id, numBuckets);
   if (index < 0) return NULL;
   TagEntry *walk = idHashBuckets[index];
   while(walk)
   {
      if(walk->id == id)
         return walk->string;
      walk = walk->idHashLink;
   }
   return NULL;
}

StringTableEntry TagDictionary::idToDefine(int id)
{
   int index = hashId(id, numBuckets);
   if (index < 0) return NULL;
   TagEntry *walk = idHashBuckets[index];
   while(walk)
   {
      if(walk->id == id)
         return walk->define;
      walk = walk->idHashLink;
   }
   return NULL;
}

//------------------------------------------------------------------------------

void TagDictionary::findIDs(Vector<int>& out_v,
                       const int    in_minID,
                       const int    in_maxID )
{
   //locate all IDs that lie in between minID and maxID

   TagEntry *walk = entryChain;
   while(walk)
   {
      if(walk->id > in_minID && walk->id < in_maxID)
         out_v.push_back(walk->id);
      walk = walk->chain;
   }
   sortIdVector(out_v);
}


//------------------------------------------------------------------------------
void TagDictionary::findStrings(Vector<int>& out_v, const char*  in_pPattern)
{
   //locate all strings that match the pattern
   //
   TagEntry *walk = entryChain;
   while(walk)
   {
      if (match(in_pPattern, walk->string))
         out_v.push_back(walk->id);
      walk = walk->chain;
   }
   sortIdVector(out_v);
}


//------------------------------------------------------------------------------
void TagDictionary::findDefines(Vector<int>& out_v, const char*  in_pPattern)
{
   //locate all define strings that match the pattern and add their ID 
   //to the given vector
   //
   TagEntry *walk = entryChain;
   while(walk)
   {
      if (match(in_pPattern, walk->define))
         out_v.push_back(walk->id);
      walk = walk->chain;
   }
   sortIdVector(out_v);
}

//------------------------------------------------------------------------------

bool TagDictionary::match(const char* pattern, const char* str)
{
   //quick and dirty recursive DOS-style wild-card string matcher
   //
   switch (*pattern) {
     case '\0':
      return !*str;

     case '*':
      return match(pattern+1, str) || *str && match(pattern, str+1);

     case '?':
      return *str && match(pattern+1, str+1);

     default:
      return (*pattern == *str) && match(pattern+1, str+1);
   }
}

//------------------------------------------------------------------------------

static _USERENTRY idCompare(const void *in_p1, const void *in_p2)
{
   return *((int *) in_p1) - *((int *) in_p2);
}

void TagDictionary::sortIdVector(Vector<int>& out_v)
{
   m_qsort(out_v.address(), out_v.size(), sizeof(int), idCompare);
}

