//================================================================
//   
// $Workfile:   lzhuff.cpp  $
// $Version$
// $Revision:   1.1  $
//   
// DESCRIPTION:
//   
// (c) Copyright Dynamix Inc.   All rights reserved.
//================================================================

#include "streamio.h"
#include "lzhstrm.h"
#include <string.h>



//---------------------------------------------------------------------------
//	Huffman Tables.
//---------------------------------------------------------------------------

// Tables for encoding and decoding the upper 6 bits of position.

// For encoding:

unsigned char LZHuffman::p_len[64] = {
	0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08
};

unsigned char LZHuffman::p_code[64] = {
	0x00, 0x20, 0x30, 0x40, 0x50, 0x58, 0x60, 0x68,
	0x70, 0x78, 0x80, 0x88, 0x90, 0x94, 0x98, 0x9C,
	0xA0, 0xA4, 0xA8, 0xAC, 0xB0, 0xB4, 0xB8, 0xBC,
	0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE,
	0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE,
	0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE,
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
	0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

// For decoding:

unsigned char LZHuffman::d_code[256] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
	0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,
	0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,
	0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,
	0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
	0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
	0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
	0x18, 0x18, 0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1B,
	0x1C, 0x1C, 0x1D, 0x1D, 0x1E, 0x1E, 0x1F, 0x1F,
	0x20, 0x20, 0x21, 0x21, 0x22, 0x22, 0x23, 0x23,
	0x24, 0x24, 0x25, 0x25, 0x26, 0x26, 0x27, 0x27,
	0x28, 0x28, 0x29, 0x29, 0x2A, 0x2A, 0x2B, 0x2B,
	0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
};

unsigned char LZHuffman::d_len[256] = {
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
};



//---------------------------------------------------------------------------
//	Huffman encoding used by the LZSS compression streams.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

LZHuffman::LZHuffman()
{
	freq = new UInt16[LZH_TABLE_SIZE + 1];
	prnt = new  Int16[LZH_TABLE_SIZE + LZH_NCHAR];
	son  = new  Int16[LZH_TABLE_SIZE];

	AssertFatal(freq != 0 && prnt != 0 && son != 0,
		"LZHuffman:: Could not allocate buffers");
}


//---------------------------------------------------------------------------

LZHuffman::~LZHuffman()
{
	delete [] freq;
	delete [] prnt;
	delete [] son;
}


//---------------------------------------------------------------------------

void LZHuffman::attach(StreamIO &s)
{
	int i, j;

	d_stream = &s;
	d_getbuf = d_getlen = 0;
	d_putbuf = d_putlen = 0;

	// Initialize the tree.

	for (i = 0; i < LZH_NCHAR; i++)
	{
		freq[i] = 1;
		son[i] = i + LZH_TABLE_SIZE;
		prnt[i + LZH_TABLE_SIZE] = i;
	}

	i = 0; j = LZH_NCHAR;

	while (j <= LZH_ROOT)
	{
		freq[j] = freq[i] + freq[i + 1];
		son[j] = i;
		prnt[i] = prnt[i + 1] = j;
		i += 2; j++;
	}

	freq[LZH_TABLE_SIZE] = 0xffff;
	prnt[LZH_ROOT] = 0;
}


//---------------------------------------------------------------------------

void LZHuffman::encodeChar(unsigned c)
{
	UInt32 i;
	int j, k;

	i = 0;
	j = 0;
	k = prnt[c + LZH_TABLE_SIZE];

	/* travel from leaf to root */
	do {
		i >>= 1;

		/* if node's address is odd-numbered, choose bigger brother node */
		if (k & 1) i += 0x8000;

		j++;

	} while ((k = prnt[k]) != LZH_ROOT);

	putCode(j,i);
	update(c);
}


//---------------------------------------------------------------------------

void LZHuffman::encodePosition(unsigned c)
{
	unsigned i;

	// Output the upper 6 bits by table lookup
	// then output the lower 6 bits verbatim

	i = c >> 6;

	putCode(p_len[i], UInt32(p_code[i] << 8));
	putCode(6, UInt32((c & 0x3f) << 10));
}


//---------------------------------------------------------------------------

int LZHuffman::decodeChar(void)
{
	unsigned c;

	c = son[LZH_ROOT];

	// Travel from root to leaf, choosing the smaller
	// child node (son[]) if the read bit is 0, the bigger
	// (son[]+1) if 1

	while (c < LZH_TABLE_SIZE)
	{
		c += getBit();
		c = son[c];
	}

	c -= LZH_TABLE_SIZE;
	update(c);
	return c;
}


//---------------------------------------------------------------------------

int LZHuffman::decodePosition(void)
{
	unsigned i, j, c;

	// Recover upper 6 bits from table

	i = getByte();
	c = (unsigned)d_code[i] << 6;
	j = d_len[i];

	// Read lower 6 bits verbatim

	j -= 2;

	while (j--)
		i = (i << 1) + getBit();

	return c | (i & 0x3f);
}


//---------------------------------------------------------------------------
// Flush the output buffer.

void LZHuffman::flush()
{
	if (d_putlen)
		d_stream->write(char(d_putbuf >> 8));
   d_stream->write(UInt8(0));
}


//---------------------------------------------------------------------------
// Private methods
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Get one bit

int LZHuffman::getBit(void)
{
	Int16	i;
	UInt8	cc;

	while (d_getlen <= 8)
	{
		if (!d_stream->read(&cc))
			cc = 0;

		d_getbuf |= UInt16(cc) << (8 - d_getlen);
		d_getlen += 8;
	}

	i = d_getbuf;

	d_getbuf <<= 1;
	d_getlen--;

	return (i < 0);
}


//---------------------------------------------------------------------------
// Get one byte

int LZHuffman::getByte(void)
{
	UInt16	i;
	UInt8		cc;

	while (d_getlen <= 8)
	{
		if (!d_stream->read(&cc))
			cc = 0;

		d_getbuf |= UInt16(cc) << (8 - d_getlen);
		d_getlen += 8;
	}

	i = d_getbuf;

	d_getbuf <<= 8;
	d_getlen -= 8;

	return i >> 8;
}


//---------------------------------------------------------------------------
// Output c bits of code.

void LZHuffman::putCode(int l, unsigned c)
{
	d_putbuf |= c >> d_putlen;

	if ((d_putlen += l) >= 8)
	{
		d_stream->write(char(d_putbuf >> 8));

		if ((d_putlen -= 8) >= 8)
		{
			d_stream->write(char(d_putbuf));

			d_putlen -= 8;
			d_putbuf = c << (l - d_putlen);
		}
		else
			d_putbuf <<= 8;
	}
}


//---------------------------------------------------------------------------
// Reconstruction of tree

void LZHuffman::reconst(void)
{
	int i, j, k;
	unsigned f, l;

	/* collect leaf nodes in the first half of the table */
	/* and replace the freq by (freq + 1) / 2. */
	j = 0;
	for (i = 0; i < LZH_TABLE_SIZE; i++) {
		if (son[i] >= LZH_TABLE_SIZE) {
			freq[j] = (freq[i] + 1) / 2;
			son[j] = son[i];
			j++;
		}
	}
	/* begin constructing tree by connecting sons */
	for (i = 0, j = LZH_NCHAR; j < LZH_TABLE_SIZE; i += 2, j++) {
		k = i + 1;
		f = freq[j] = freq[i] + freq[k];
		for (k = j - 1; int(f) < freq[k]; k--)
			;
		k++;
		l = (j - k) * 2;
		memmove(&freq[k + 1], &freq[k], l);
		freq[k] = f;
		memmove(&son[k + 1], &son[k], l);
		son[k] = i;
	}
	/* connect prnt */
	for (i = 0; i < LZH_TABLE_SIZE; i++) {
		if ((k = son[i]) >= LZH_TABLE_SIZE) {
			prnt[k] = i;
		} else {
			prnt[k] = prnt[k + 1] = i;
		}
	}
}


//---------------------------------------------------------------------------
// Increment frequency of given code by one, and update tree

void LZHuffman::update(int c)
{
	int i, j, k, l;

	if (freq[LZH_ROOT] == LZH_MAX_FREQ)
		reconst();

	c = prnt[c + LZH_TABLE_SIZE];

	do
	{
		k = ++freq[c];

		/* if the order is disturbed, exchange nodes */
		if (k > freq[l = c + 1]) {
			while (k > freq[++l])
				;
			l--;
			freq[c] = freq[l];
			freq[l] = k;

			i = son[c];
			prnt[i] = l;
			if (i < LZH_TABLE_SIZE) prnt[i + 1] = l;

			j = son[l];
			son[l] = i;

			prnt[j] = c;
			if (j < LZH_TABLE_SIZE) prnt[j + 1] = c;
			son[c] = j;

			c = l;
		}
	} while ((c = prnt[c]) != 0);	/* repeat up to root */
}





